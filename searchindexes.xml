<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>GitHub代理加速</title><url>/posts/git/github%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[项目地址： https://github.com/hunshcn/gh-proxy 使用cloudflare免费的代理加速 网址： https://workers.cloudflare.com 先登录或注册 将下面的放入左侧的方框中(不需要任何的改动)
&#39;use strict&#39; /** * static files (404.html, sw.js, conf.js) */ const ASSET_URL = &#39;https://hunshcn.github.io/gh-proxy/&#39; // 前缀，如果自定义路由为example.com/gh/*，将PREFIX改为 &#39;/gh/&#39;，注意，少一个杠都会错！ const PREFIX = &#39;/&#39; // 分支文件使用jsDelivr镜像的开关，0为关闭，默认关闭 const Config = { jsdelivr: 0 } const whiteList = [] // 白名单，路径里面有包含字符的才会通过，e.g. [&#39;/username/&#39;] /** @type {RequestInit} */ const PREFLIGHT_INIT = { status: 204, headers: new Headers({ &#39;access-control-allow-origin&#39;: &#39;*&#39;, &#39;access-control-allow-methods&#39;: &#39;GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS&#39;, &#39;access-control-max-age&#39;: &#39;1728000&#39;, }), } const exp1 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/(?:releases|archive)\/.*$/i const exp2 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/(?:blob|raw)\/.*$/i const exp3 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/(?:info|git-).*$/i const exp4 = /^(?:https?:\/\/)?raw\.(?:githubusercontent|github)\.com\/.+?\/.+?\/.+?\/.+$/i const exp5 = /^(?:https?:\/\/)?gist\.(?:githubusercontent|github)\.com\/.+?\/.+?\/.+$/i const exp6 = /^(?:https?:\/\/)?github\.com\/.+?\/.+?\/tags.*$/i /** * @param {any} body * @param {number} status * @param {Object&lt;string, string&gt;} headers */ function makeRes(body, status = 200, headers = {}) { headers[&#39;access-control-allow-origin&#39;] = &#39;*&#39; return new Response(body, {status, headers}) } /** * @param {string} urlStr */ function newUrl(urlStr) { try { return new URL(urlStr) } catch (err) { return null } } addEventListener(&#39;fetch&#39;, e =&gt; { const ret = fetchHandler(e) .catch(err =&gt; makeRes(&#39;cfworker error:\n&#39; + err.stack, 502)) e.respondWith(ret) }) function checkUrl(u) { for (let i of [exp1, exp2, exp3, exp4, exp5, exp6]) { if (u.search(i) === 0) { return true } } return false } /** * @param {FetchEvent} e */ async function fetchHandler(e) { const req = e.request const urlStr = req.url const urlObj = new URL(urlStr) let path = urlObj.searchParams.get(&#39;q&#39;) if (path) { return Response.redirect(&#39;https://&#39; + urlObj.host + PREFIX + path, 301) } // cfworker 会把路径中的 `//` 合并成 `/` path = urlObj.href.substr(urlObj.origin.length + PREFIX.length).replace(/^https?:\/+/, &#39;https://&#39;) if (path.search(exp1) === 0 || path.search(exp5) === 0 || path.search(exp6) === 0 || path.search(exp3) === 0 || path.search(exp4) === 0) { return httpHandler(req, path) } else if (path.search(exp2) === 0) { if (Config.jsdelivr) { const newUrl = path.replace(&#39;/blob/&#39;, &#39;@&#39;).replace(/^(?:https?:\/\/)?github\.com/, &#39;https://cdn.jsdelivr.net/gh&#39;) return Response.redirect(newUrl, 302) } else { path = path.replace(&#39;/blob/&#39;, &#39;/raw/&#39;) return httpHandler(req, path) } } else if (path.search(exp4) === 0) { const newUrl = path.replace(/(?&lt;=com\/.+?\/.+?)\/(.+?\/)/, &#39;@$1&#39;).replace(/^(?:https?:\/\/)?raw\.(?:githubusercontent|github)\.com/, &#39;https://cdn.jsdelivr.net/gh&#39;) return Response.redirect(newUrl, 302) } else { return fetch(ASSET_URL + path) } } /** * @param {Request} req * @param {string} pathname */ function httpHandler(req, pathname) { const reqHdrRaw = req.headers // preflight if (req.method === &#39;OPTIONS&#39; &amp;&amp; reqHdrRaw.has(&#39;access-control-request-headers&#39;) ) { return new Response(null, PREFLIGHT_INIT) } const reqHdrNew = new Headers(reqHdrRaw) let urlStr = pathname let flag = !Boolean(whiteList.length) for (let i of whiteList) { if (urlStr.includes(i)) { flag = true break } } if (!flag) { return new Response(&#34;blocked&#34;, {status: 403}) } if (urlStr.startsWith(&#39;github&#39;)) { urlStr = &#39;https://&#39; + urlStr } const urlObj = newUrl(urlStr) /** @type {RequestInit} */ const reqInit = { method: req.method, headers: reqHdrNew, redirect: &#39;manual&#39;, body: req.body } return proxy(urlObj, reqInit) } /** * * @param {URL} urlObj * @param {RequestInit} reqInit */ async function proxy(urlObj, reqInit) { const res = await fetch(urlObj.href, reqInit) const resHdrOld = res.headers const resHdrNew = new Headers(resHdrOld) const status = res.status if (resHdrNew.has(&#39;location&#39;)) { let _location = resHdrNew.get(&#39;location&#39;) if (checkUrl(_location)) resHdrNew.set(&#39;location&#39;, PREFIX + _location) else { reqInit.redirect = &#39;follow&#39; return proxy(newUrl(_location), reqInit) } } resHdrNew.set(&#39;access-control-expose-headers&#39;, &#39;*&#39;) resHdrNew.set(&#39;access-control-allow-origin&#39;, &#39;*&#39;) resHdrNew.delete(&#39;content-security-policy&#39;) resHdrNew.delete(&#39;content-security-policy-report-only&#39;) resHdrNew.delete(&#39;clear-site-data&#39;) return new Response(res.body, { status, headers: resHdrNew, }) } 点击保存并部署后可以点击发送测试是否成功 目前国内无法访问 *.workers.dev，需要cloudflare托管的域名反代进行CNAME解析 之后点击Worker路由-&gt; 添加路由 按照下图的形式编写进行保存即可 之后就能通过自定义的域名进行访问
终端使用方法 例如下载 Releases 文件
# 原来的使用方法 wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz # 代理使用方法 wget https://gitpy.colzry.tk/https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz clone也是如此
]]></content></entry><entry><title>Git的基本使用</title><url>/posts/git/git%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[1. 设置签名 git config --global user.name tom #设置用户名tom git config --global user.email xxx@qq.com #设置用户邮箱 2. 创建本地仓库 $ git init 3. 版本提交 3.1 状态查看 git status #查看工作区、暂存区状态 3.2 添加 git add fileName #指定文件 git add . #所有 说明：将工作区的文件添加到暂存区 3.3 提交 git commit -m &#39;commit message&#39; 说明：将暂存区内容提交到本地库 3.4 查看历史记录 git log git reflog #常用 git log --greph #图形显示,更直观 git log --pretty=oneline #漂亮一行显示 git log --oneline #简洁显示 说明：HEAD@{移动到当前版本需要多少步} 4. 分支操作 4.1 创建分支 git branch 分支名 4.2 查看分支 git branch git branch -v 4.3 切换分支 git checkout 分支名 git checkout -b 分支名 #创建分支并直接切换到该分支 4.4 重命名分支 在当前分支
git branch -m new_branch_name 不在当前分支
git branch -m old_name new_name 4.5 合并分支 **相当于把修改了的文件拉过来**
git rebase &lt;branch&gt; 将指定的分支合并到当前分支 git merge --no-ff xxx 注意：合并分支的时候要明确谁谁合并 我在a分支里面修改了。要合并到master，就先切换到master，然后合并b 4.6 删除分支 git branch -d 分支名 5. 使用远程仓库 5.1 创建远程库地址别名 git remote -v #查看远程地址别名 git remote add 别名 远程地址 git remote set-url 别名 远程地址 例子：git remote add origin https://xx 5.2 推送 **开发修改完把本地库的文件推送到远程仓库**** ****前提是提交到了本地库才可以推送**
git push 别名 分支名 git push -u 别名 分支名 #-u指定默认主机 git push -f # 强制推送 例子：git push origin master 5.3 克隆 **完整的把远程库克隆到本地**** **克隆下来后不要在主分支里面做开发** ****clone进行一次，从无到有的过程，更新用pull**
git clone 远程地址 例子：git clone https://xx 5.4 拉取 **本地存在clone下来的文件 就用pull更新**
pull = fetch + merge git fetch 别名 分支名 git merge 别名 分支名 git pull 别名 分支名 5.5 解决冲突 注意：解决冲突后的提交是不能带文件名的 如果不是基于远程库最新版做的修改不能推送，必须先pull下来安装冲突办法解决
# 查看所有分支 git reflog # 回退到上一个版本 git rest --hard HEAD^ # 回退到上上个版本 git rest --hard HEAD^^ # 回退到commit id为ba7914b的版本 git rest --hard ba7914b git pull origin/master # 合并之后修改冲突 git diff origin/master ]]></content></entry><entry><title>Git设置代理</title><url>/posts/git/git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[# 以下使用http代理 git config --global http.proxy http://127.0.0.1:10809 git config --global https.proxy https://127.0.0.1:10809 # 以下使用socks5代理 git config --global http.proxy socks5://127.0.0.1:10808 git config --global https.proxy socks5://127.0.0.1:10808 # 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy git config --global url.&#34;https://gitpy.colzry.tk/&#34;.insteadOf https:// git config --global --remove-section url.&#34;https://gitpy.colzry.tk/&#34; ]]></content></entry><entry><title>go mod的使用</title><url>/posts/golang/go-mod/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"><![CDATA[常用命令
# 初始化模块 cd &lt;mod_name&gt; go mod init &lt;mod_name&gt; # 删除没用的依赖，下载位拉取的依赖 go mod tidy go mod使用 | 全网最详细 ]]></content></entry><entry><title>go workspace快速使用</title><url>/posts/golang/go-workspace/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html">常用命令
# 初始化工作区 go work init [dirnames] # 添加模块 go work use [dirnames] 官方博文：Go 1.18工作区模式最佳实践 Go 1.18 workspace 使用初体验_Seekload的博客-CSDN博客</content></entry><entry><title>Golang1.18泛型新特性</title><url>/posts/golang/1.18-%E6%B3%9B%E5%9E%8B%E6%96%B0%E7%89%B9%E6%80%A7/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"> Go 1.18 泛型全面讲解：一篇讲清泛型的全部</content></entry><entry><title>Go语言快速上手</title><url>/posts/golang/go%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"><![CDATA[在Linux上安装GoLang wget https://golang.google.cn/dl/go1.19.1.linux-amd64.tar.gz rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz echo &#39;export PATH=$PATH:/usr/local/go/bin&#39; &gt;&gt; $HOME/.profile source $HOME/.profile go version go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 在Windows上安装GoLang 官网地址 国内镜像地址 下载.msi文件安装后，配置环境变量
将安装的Go\bin 目录添加到 Path 环境变量中
将工作目录也添加到环境变量中
确认之后检查是否成功
配置开发环境 配置「七牛云」的代理服务
$ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn,direct 配置工作路径
go env -w GOPATH=C:\WorkDir\Go # 这是我的工作路径，填自己的 打开vscode安装GO语言的插件
之后工作目录下新建一个src目录，在该目录下创建xxx.go文件，根据vscode的提示安装所有的包
变量的声明 // 法一 var num int = 100 var str string = &#34;123&#34; // 法二 知道变量的值后可以不用声明属性 var num = 100 var str = &#34;123&#34; // 法三 此方法只能用在局部变量中 num := 100 str := &#34;123&#34; // 多行声明 var num, str = 100, &#34;123&#34; var ( num = 100 str = &#34;123&#34; ) num, str := 100, &#34;123&#34; 常量的定义 // 常量只读，不允许修改 const num int = 100 // const 用来定义枚举类型 const ( // 可以在 const() 中添加关键字 iota(也只能在const 中使用), iota 会自增，第一行默认为 1 January = iota // iota = 0 February // iota = 1 March // iota = 2 April // iota = 3 May // ... ... June July ) 函数的返回值 package main import &#34;fmt&#34; // 1个匿名返回值 func demo1(a int) int { b := a * 2 return b } // 2个匿名返回值 func demo2(a int, b int) (int, int) { return a * 2, b * 3 } // 不匿名的返回 func demo3(a int, b int) (r1 int, r2 int) { r1 = a * 2 r2 = b * 3 return } func demo4(a int, b int) (r1, r2 int){ } func main() { ret1 := demo1(10) fmt.Printf(&#34;ret1 = %d\n&#34;, ret1) ret2, ret3 := demo2(10, 20) fmt.Printf(&#34;ret2 = %d, ret3 = %d\n&#34;, ret2, ret3) ret4, ret5 := demo3(100, 200) fmt.Printf(&#34;ret4 = %d, ret5 = %d\n&#34;, ret4, ret5) } init() 函数和import // 程序会先执行最里面的包的init()方法 **注意：**函数名开头大写表示函数是public, 小写表示函数是private
import ( _ &#34;$GOPATH/xxx/xxx&#34; // 匿名导包，不调用也会执行init() name &#34;$GOPATH/xxx/xxx&#34; // 起别名 . &#34;$GOPATH/xxx/xxx&#34; // 导入到当前程序中，可直接使用包内的方法 ) defer 语句的调用顺序 defer在函数的生命周期结束后调用(在return之后)，遵循先进后出原则
package main import &#34;fmt&#34; func fun1() { fmt.Println(&#34;this is fun1 called&#34;) } func fun2() int { fmt.Println(&#34;this is fun2 called&#34;) return fun3() } func fun3() int { fmt.Println(&#34;this is fun3 called&#34;) return 0 } func main() { defer fun1() defer fun2() } /* 结果 this is fun2 called this is fun3 called this is fun1 called */ 静态数组和动态数值 // 静态数组，上来就声明长度或者内容,有着固定长度 arr1 := [4]int{1,2,3,4} arr2 := [10]int{1,2,3,4} // 前四有值，后面的全为0 var arr3 [5]int // 定义五个为0的数组 // 动态数组没有固定的长度，也叫 切片 (其本质为指针) slice := []int{1,2,3} // 默认值 1 2 3 长度为3 len=3 , cap = 3 slice1 := make([]int, len, cap) // len &lt;= cap slice2 := make([]int, 3) // len = 3, cap = 3 // 切片的追加 slice1 = append(slice1, 1) // 向slice1追加一个值为1的元素 // 若向一个容量已满的切片追加，则会新建一个之前两倍容量的切片， // 之后将旧的切片赋值给新的切片，在新的切片上进行追加 // 切片的截取 slice4 := []int{1,2,3,4,5,6} // 若修改num，则slice4也会改变 浅拷贝 num := slice4[0:3] // 左闭右开 [:2] [1:] // 深拷贝 num2 := make([]int, 3) copy(num2, slice4) map的使用 和切片一样，是动态的，要分配空间
|-&gt;值 mymap := make(map[int]string, 10) // map[key]value / cap = 10 |-&gt; 键 mymap[0] = &#34;Jun&#34; mymap[1] = &#34;xxx&#34; ... ... mymap1 := make(map[int]string) // 可以不加容量 mymap := map[string]string{ &#34;one&#34;: &#34;Jun&#34;, &#34;tow&#34;: &#34;Fer&#34;, &#34;key&#34;: &#34;vlaue&#34; } // 删除 delete(mymap, &#34;key&#34;) // 遍历 for key, value := range mymap { fmt.Println(&#34;key = &#34;, key) fmt.Println(&#34;value = &#34;, value) } **注意：**map 和 切片 传参时传的是指针，因此改变值时，原来的也会改变
结构体 // 大写表示public 小写表示private type book struct{ name string autoh string price int } type Student struct { Name string Gender string Age int8 } 结构体之间的嵌套可以看作继承 type Personal struct { Name string Age int Gender string } // Student 继承 Personal type Student struct { Personal Classroom string } // 与结构体绑定方法 // 父类的方法 func (p Personal) Run() { fmt.Println(p.Name + &#34;在奔跑~~~~~~~~&#34;) } // 子类的方法 func (t Student) HaveClass() { fmt.Println(t.Name + &#34;在&#34; + t.Classroom + &#34;上课&#34;) } func main() { var s = Student{ Personal: Personal{ &#34;Colzry&#34;, 21, &#34;男&#34;, }, Classroom: &#34;16班&#34;, } fmt.Printf(&#34;%#v\n&#34;, s) // 调用父类的方法 s.Run() // 调用自己的方法 s.HaveClass() } 接口 使用接口来规范结构体的方法 package main import &#34;fmt&#34; //定义一个接口 type Operate interface { start() stop() } type Phone struct { Name string } // 让结构体实现接口 func (p Phone) start() { fmt.Println(p.Name + &#34;开机&#34;) } func (p Phone) stop() { fmt.Println(p.Name + &#34;关机&#34;) } func main() { // 实例化接口 var redmi Operate = Phone{Name: &#34;RedMi k40&#34;} // 调用实现的方法 redmi.start() redmi.stop() } 使用空接口来做泛型 var a interface{} a = 20 fmt.Printf(&#34;a的值: %v, a的类型: %T\n&#34;, a, a) a = &#34;Colzry&#34; fmt.Printf(&#34;a的值: %v, a的类型: %T\n&#34;, a, a) a = true fmt.Printf(&#34;a的值: %v, a的类型: %T\n&#34;, a, a) a = []int{1, 2, 3} fmt.Printf(&#34;a的值: %v, a的类型: %T\n&#34;, a, a) b := make(map[interface{}]interface{}) b[4] = true b[&#34;str&#34;] = 25 fmt.Println(b) c := []interface{}{1, 2, &#34;3&#34;, true} fmt.Println(c) ######## 打印 ########## a的值: 20, a的类型: int a的值: Colzry, a的类型: string a的值: true, a的类型: bool a的值: [1 2 3], a的类型: []int map[4:true str:25] [1 2 3 true] 常用在函数的参数和返回值处
func getObj(value interface{}) interface{} { return value } 类型断言 package main import &#34;fmt&#34; // 类型断言 func TypePrint(value interface{}) { // 两种判断类型的方法(if switch)，但是switch只能使用 x.(type) if _, ok := value.(string); ok { fmt.Println(&#34;它居然是个字符串&#34;) } else { fmt.Println(&#34;可惜它不是字符串&#34;) } switch value.(type) { case int: fmt.Println(&#34;int类型&#34;) case string: fmt.Println(&#34;string类型&#34;) case bool: fmt.Println(&#34;bool类型&#34;) case []int: fmt.Println(&#34;[]int类型&#34;) default: fmt.Println(&#34;不在列表范围内&#34;) } } func main() { a := 20 TypePrint(a) b := &#34;Colzry&#34; TypePrint(b) } 打印
可惜它不是字符串 int类型 它居然是个字符串 string类型 协程 使用关键字go可以将一个方法(函数)作为协程来使用
func main() { go test() for i := 0; i &lt; 10; i++ { fmt.Println(&#34;main ---------------&#34;, i) time.Sleep(time.Millisecond * 500) } } func test() { for i := 0; i &lt; 10; i++ { fmt.Println(&#34;test ---------------&#34;, i) time.Sleep(time.Millisecond * 1000) } } 这样main函数和test函数就能同时运行，但会出现一个问题，main函数会因为先结束而导致test函数没运行完就结束了，这时需要使用异步
import ( &#34;fmt&#34; &#34;sync&#34; &#34;time&#34; ) var wg sync.WaitGroup func main() { wg.Add(1) // 添加一个协程 go test() // 启动一个协程 for i := 0; i &lt; 10; i++ { fmt.Println(&#34;main ---------------&#34;, i) time.Sleep(time.Millisecond * 500) } wg.Wait() // 等待所有协程执行完 } func test() { for i := 0; i &lt; 10; i++ { fmt.Println(&#34;test ---------------&#34;, i) time.Sleep(time.Millisecond * 1000) } wg.Done() // 完成一个协程 } Add, Wait, Done 需要一起出现 管道 使用关键字chan定义一个管道(注意：管道也是地址引用型)
var ch chan int // 类型为 int 型 ch = make(chan int, 10) // 给管道ch分配10个空间 ch &lt;- 10 // 将10写入管道ch中 value := &lt;- ch // 取出管道中的第一个值，也可匿名取出 &lt;- ch close(ch) // 关闭管道 管道中的值遵循先进先出，一旦没有导致取不出或者满了导致放不了都会报错，错误如下
fatal error: all goroutines are asleep - deadlock! 使用for range 遍历管道时要先关闭管道
func main() { ch := make(chan int, 10) for i := 0; i &lt; 10; i++ { ch &lt;- i } close(ch) for v := range ch{ fmt.Println(v) } } 单向管道
chan&lt;- // 只写 &lt;-chan // 只读 ch1 = make(chan&lt;- int, 10) // 只写的int管道 ch2 = make(&lt;-chan int, 10) // 只读的int管道 // 形参表示 func fn1(ch chan&lt;- int){} func fn2(ch &lt;-chan int){} 管道和线程的使用 package main import ( &#34;fmt&#34; &#34;sync&#34; &#34;time&#34; ) var wg sync.WaitGroup func fn1(ch chan int){ for i := 1; i &lt;= 10; i++ { ch &lt;- i fmt.Println(&#34;写入&#34;, i, &#34;成功&#34;) time.Sleep(time.Millisecond * 100) } close(ch) wg.Done() } func fn2(ch chan int) { for v := range ch{ fmt.Println(&#34;读取&#34;, v, &#34;成功&#34;) time.Sleep(time.Millisecond * 10) } wg.Done() } func main() { ch := make(chan int, 10) wg.Add(2) go fn1(ch) go fn2(ch) wg.Wait() } package main import ( &#34;fmt&#34; &#34;sync&#34; ) var wg sync.WaitGroup func putNum(numChan chan int) { for i := 2; i &lt;= 1200000; i++ { numChan &lt;- i } close(numChan) wg.Done() } func getPrime(numChan chan int, primeChan chan int, exitChan chan bool) { for num := range numChan { flag := true for i := 2; i &lt; num; i++ { if num % i == 0 { flag = false break } } if flag { primeChan &lt;- num } } // 存放素数管道完成数 +1 exitChan &lt;- true wg.Done() } func printPrime(primeChan chan int) { for v := range primeChan{ fmt.Println(v) } wg.Done() } func main() { numChan := make(chan int, 1000) // 存放数字的管道 primeChan := make(chan int, 1000) // 存放素数的管道 exitChan := make(chan bool, 16) // 存放素数管道完成数 count := 20 // 判断素数的协程数 wg.Add(1) go putNum(numChan) for i := 0; i &lt; count; i++ { wg.Add(1) go getPrime(numChan, primeChan, exitChan) } wg.Add(1) go printPrime(primeChan) wg.Add(1) go func() { for i := 0; i &lt; count; i++ { &lt;- exitChan // 存放素数管道完成数 -1 } // 判断存放素数管道完成数都运行完后关闭管道 close(primeChan) wg.Done() }() wg.Wait() fmt.Println(&#34;执行结束......&#34;) } 多路复用 多路复用使用select关键字，通常搭配for使用，让case中的代码随机的执行，也叫并发
package main import &#34;fmt&#34; func main() { intChan := make(chan int, 10) strChan := make(chan string, 10) for i := 0; i &lt; 10; i++ { intChan &lt;- i strChan &lt;- &#34;hello&#34; + fmt.Sprint(i) } for { select { case v := &lt;- intChan: fmt.Println(&#34;intChan 读取的数据&#34;, v) case v := &lt;-strChan: fmt.Println(&#34;strChan 读取的数据&#34;, v) default: fmt.Println(&#34;结束&#34;) return } } } goroutine异常处理 使用defer + recover进行异常捕获
defer func(){ if err := recover(); err != nil { fmt.Println(&#34;发生错误&#34;, err) } }() package main import ( &#34;fmt&#34; &#34;time&#34; ) func fn1() { defer func(){ if err := recover(); err != nil { fmt.Println(&#34;发生错误&#34;, err) } }() var name map[int]string name[0] = &#34;test&#34; } func fn2() { for i := 0; i &lt; 10; i++ { fmt.Println(&#34;hell0&#34;, i) } } func main() { go fn1() go fn2() time.Sleep(time.Second * 5) } ]]></content></entry><entry><title>Containerd安装</title><url>/posts/docker/containerd%E5%AE%89%E8%A3%85/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[官方下载地址：https://github.com/containerd/containerd/releases
wget https://github.com/containerd/containerd/releases/download/v1.6.8/cri-containerd-cni-1.6.8-linux-amd64.tar.gz mkdir cri-containerd-cni &amp;&amp; tar -zxvf cri-containerd-cni-1.6.8-linux-amd64.tar.gz -C cri-containerd-cni 复制配置文件
cp cri-containerd-cni/etc/crictl.yaml /etc/ cp cri-containerd-cni/etc/systemd/system/containerd.service /etc/systemd/system/ # 复制 containerd 和相关依赖 cp cri-containerd-cni/usr/local/bin/. /usr/local/bin/ -a # 复制runc文件 cp cri-containerd-cni/usr/local/sbin/. /usr/local/sbin/ -a 生成和配置启动文件 # 1. 创建文件夹 mkdir -p /etc/containerd # 2. 生成配置文件 containerd config default &gt; /etc/containerd/config.toml vim /etc/containerd/config.toml disabled_plugins = [] imports = [] oom_score = 0 plugin_dir = &#34;&#34; required_plugins = [] root = &#34;/var/lib/containerd&#34; state = &#34;/run/containerd&#34; version = 2 [cgroup] path = &#34;&#34; [debug] address = &#34;&#34; format = &#34;&#34; gid = 0 level = &#34;&#34; uid = 0 [grpc] address = &#34;/run/containerd/containerd.sock&#34; gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 tcp_address = &#34;&#34; tcp_tls_cert = &#34;&#34; tcp_tls_key = &#34;&#34; uid = 0 [metrics] address = &#34;&#34; grpc_histogram = false [plugins] [plugins.&#34;io.containerd.gc.v1.scheduler&#34;] deletion_threshold = 0 mutation_threshold = 100 pause_threshold = 0.02 schedule_delay = &#34;0s&#34; startup_delay = &#34;100ms&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;] disable_apparmor = false disable_cgroup = false disable_hugetlb_controller = true disable_proc_mount = false disable_tcp_service = true enable_selinux = false enable_tls_streaming = false ignore_image_defined_volumes = false max_concurrent_downloads = 3 max_container_log_line_size = 16384 netns_mounts_under_state_dir = false restrict_oom_score_adj = false # sandbox_image = &#34;k8s.gcr.io/pause:3.5&#34; # 1. 修改基础镜像地址 sandbox_image = &#34;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.5&#34; selinux_category_range = 1024 stats_collect_period = 10 stream_idle_timeout = &#34;4h0m0s&#34; stream_server_address = &#34;127.0.0.1&#34; stream_server_port = &#34;0&#34; systemd_cgroup = false tolerate_missing_hugetlb_controller = true unset_seccomp_profile = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.cni] bin_dir = &#34;/opt/cni/bin&#34; conf_dir = &#34;/etc/cni/net.d&#34; conf_template = &#34;&#34; max_conf_num = 1 [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd] default_runtime_name = &#34;runc&#34; disable_snapshot_annotations = true discard_unpacked_layers = false no_pivot = false snapshotter = &#34;overlayfs&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.default_runtime] base_runtime_spec = &#34;&#34; container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = &#34;&#34; runtime_root = &#34;&#34; runtime_type = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.default_runtime.options] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.runc] base_runtime_spec = &#34;&#34; container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = &#34;&#34; runtime_root = &#34;&#34; runtime_type = &#34;io.containerd.runc.v2&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.runc.options] BinaryName = &#34;&#34; CriuImagePath = &#34;&#34; CriuPath = &#34;&#34; CriuWorkPath = &#34;&#34; IoGid = 0 IoUid = 0 NoNewKeyring = false NoPivotRoot = false Root = &#34;&#34; ShimCgroup = &#34;&#34; SystemdCgroup = false [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.untrusted_workload_runtime] base_runtime_spec = &#34;&#34; container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = &#34;&#34; runtime_root = &#34;&#34; runtime_type = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.untrusted_workload_runtime.options] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.image_decryption] key_model = &#34;node&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry] config_path = &#34;&#34; [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.auths] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.configs] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.headers] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors] # 2. 设置仓库地址 [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;docker.io&#34;] endpoint = [&#34;https://usydjf4t.mirror.aliyuncs.com&#34;] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.registry.mirrors.&#34;k8s.gcr.io&#34;] endpoint = [&#34;https://registry.cn-hangzhou.aliyuncs.com/google_containers&#34;] [plugins.&#34;io.containerd.grpc.v1.cri&#34;.x509_key_pair_streaming] tls_cert_file = &#34;&#34; tls_key_file = &#34;&#34; [plugins.&#34;io.containerd.internal.v1.opt&#34;] path = &#34;/opt/containerd&#34; [plugins.&#34;io.containerd.internal.v1.restart&#34;] interval = &#34;10s&#34; [plugins.&#34;io.containerd.metadata.v1.bolt&#34;] content_sharing_policy = &#34;shared&#34; [plugins.&#34;io.containerd.monitor.v1.cgroups&#34;] no_prometheus = false [plugins.&#34;io.containerd.runtime.v1.linux&#34;] no_shim = false runtime = &#34;runc&#34; runtime_root = &#34;&#34; shim = &#34;containerd-shim&#34; shim_debug = false [plugins.&#34;io.containerd.runtime.v2.task&#34;] platforms = [&#34;linux/amd64&#34;] [plugins.&#34;io.containerd.service.v1.diff-service&#34;] default = [&#34;walking&#34;] [plugins.&#34;io.containerd.snapshotter.v1.aufs&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.btrfs&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.devmapper&#34;] async_remove = false base_image_size = &#34;&#34; pool_name = &#34;&#34; root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.native&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.overlayfs&#34;] root_path = &#34;&#34; [plugins.&#34;io.containerd.snapshotter.v1.zfs&#34;] root_path = &#34;&#34; [proxy_plugins] [stream_processors] [stream_processors.&#34;io.containerd.ocicrypt.decoder.v1.tar&#34;] accepts = [&#34;application/vnd.oci.image.layer.v1.tar+encrypted&#34;] args = [&#34;--decryption-keys-path&#34;, &#34;/etc/containerd/ocicrypt/keys&#34;] env = [&#34;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&#34;] path = &#34;ctd-decoder&#34; returns = &#34;application/vnd.oci.image.layer.v1.tar&#34; [stream_processors.&#34;io.containerd.ocicrypt.decoder.v1.tar.gzip&#34;] accepts = [&#34;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&#34;] args = [&#34;--decryption-keys-path&#34;, &#34;/etc/containerd/ocicrypt/keys&#34;] env = [&#34;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&#34;] path = &#34;ctd-decoder&#34; returns = &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34; [timeouts] &#34;io.containerd.timeout.shim.cleanup&#34; = &#34;5s&#34; &#34;io.containerd.timeout.shim.load&#34; = &#34;5s&#34; &#34;io.containerd.timeout.shim.shutdown&#34; = &#34;3s&#34; &#34;io.containerd.timeout.task.state&#34; = &#34;2s&#34; [ttrpc] address = &#34;&#34; gid = 0 uid = 0 启动 systemctl daemon-reload systemctl enable containerd --now systemctl status containerd ]]></content></entry><entry><title>Docker换源</title><url>/posts/docker/%E6%8D%A2%E6%BA%90/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[Podman换源 网易 hub-mirror.c.163.com USTC docker.mirrors.ustc.edu.cn vim /etc/containers/registries.conf ################################################ unqualified-search-registries = [&#34;docker.io&#34;] [[registry]] prefix = &#34;docker.io&#34; location = &#34;l6p4ic76.mirror.aliyuncs.com&#34; ################################################# Docker换源 vim /etc/docker/daemon.json { &#34;registry-mirrors&#34;: [&#34;https://l6p4ic76.mirror.aliyuncs.com&#34;], &#34;log-driver&#34;:&#34;json-file&#34;, &#34;log-opts&#34;: {&#34;max-size&#34;:&#34;500m&#34;, &#34;max-file&#34;:&#34;3&#34;} } systemctl restart docker &gt; 南京大学 https://docker.nju.edu.cn/ &gt; 网易 http://hub-mirror.c.163.com &gt; 腾讯云 docker hub mirror https://mirror.ccs.tencentyun.com &gt; docker中国 https://registry.docker-cn.com &gt; 我的 daocloud http://f1361db2.m.daocloud.io &gt; 我的华为云 https://326fcbdbb5c7487aa2d8180833e71119.mirror.swr.myhuaweicloud.com ) 我的阿里云 https://l6p4ic76.mirror.aliyuncs.com 查看镜像源 docker info podman info ]]></content></entry><entry><title>K8S集群部署</title><url>/posts/docker/k8s%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[官网地址：https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/
1. 搭建单Master集群 创建一个 Master 节点 kubeadm init 将 Node节点加入到当前集群中 kubeadm join &lt;Master节点的IP和端口&gt; 环境准备 工作节点 主机名 IP地址 系统版本 master k8s-master 192.168.211.201 almalinux8.6 node1 k8s-node1 192.168.211.202 almalinux8.6 node2 k8s-node2 192.168.211.203 almalinux8.6 注意： 从 2 - 5 的内容在在master和node节点主机在都要执行
2. 安装前准备 2.1 修改和添加主机名 # 修改主机名 # 在master节点执行 hostnamectl set-hostname k8s-master # 在node节点执行 hostnamectl set-hostname k8s-node1 hostnamectl set-hostname k8s-node2 # 添加主机名 cat &gt;&gt; /etc/hosts &lt;&lt; EOF 192.168.211.201 k8s-master 192.168.211.202 k8s-node1 192.168.211.203 k8s-node2 EOF 2.2 关闭防火墙 systemctl stop firewalld systemctl disable firewalld 2.3 关闭 selinux sed -i &#39;s/SELINUX=enforcing/SELINUX=disabled/g&#39; /etc/sysconfig/selinux setenforce 0 2.4 关闭swap分区 先临时关闭，再永久关闭，这样就不用重启 # 临时关闭 swapoff -a # 永久关闭 sed -ri &#39;s/.*swap.*/#&amp;/&#39; /etc/fstab # 重启生效 # 查看效果 free -m # 重新启动swap分区 swapon -a 2.5 网桥过滤 cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-arptables = 1 net.ipv4.ip_forward=1 net.ipv4.ip_forward_use_pmtu = 0 EOF # 生效命令 sysctl --system 2.6 时间同步 # 安装软件 yum -y install ntpdate # 向阿里云服务器同步时间 ntpdate time1.aliyun.com # 删除本地时间并设置时区为上海 rm -rf /etc/localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 查看时间 date -R || date 3. 所有节点安装Docker 1.卸载旧版本 yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 2.安装需要的依赖包	yum install -y yum-utils 3.设置阿里云docker镜像 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo &amp;&amp; yum makecache 4.安装docker yum -y install docker-ce docker-ce-cli containerd.io 5.启动Docker systemctl start docker &amp;&amp; systemctl enable docker &amp;&amp; systemctl status docker 6.查看docker版本信息 docker info 4. 所有节点配置阿里云Docker、kubernetes镜像 1. 配置阿里云docker镜像加速 mkdir -p /etc/docker cat &gt; /etc/docker/daemon.json &lt;&lt; EOF { &#34;registry-mirrors&#34;: [&#34;https://l6p4ic76.mirror.aliyuncs.com&#34;], &#34;log-driver&#34;:&#34;json-file&#34;, &#34;exec-opts&#34;: [&#34;native.cgroupdriver=systemd&#34;], &#34;log-opts&#34;: {&#34;max-size&#34;:&#34;500m&#34;, &#34;max-file&#34;:&#34;3&#34;} } EOF systemctl restart docker 2. 配置阿里云Kubernetes 镜像 cat &gt;&gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF 5. 所有节点安装kubelet kubeadm kubectl yum install -y --nogpgcheck kubelet-1.22.15 kubeadm-1.22.15 kubectl-1.22.15 # 指定K8S版本安装，不指定版本默认安装最新版。 # yum install -y --nogpgcheck kubelet kubeadm kubectl systemctl enable kubelet &amp;&amp; systemctl start kubelet 6. 部署Kubernetes Master节点 这里指定阿里云镜像仓库地址，默认的镜像地址无法加载访问。
kubeadm init \ --apiserver-advertise-address=192.168.211.201 \ --image-repository registry.aliyuncs.com/google_containers \ --kubernetes-version v1.22.15 \ --service-cidr=10.96.0.0/12 \ --pod-network-cidr=10.244.0.0/16 若出现错误
[root@almalinux ~]# kubeadm init \ &gt; --apiserver-advertise-address=192.168.211.201 \ &gt; --image-repository registry.aliyuncs.com/google_containers \ &gt; --kubernetes-version v1.25.3 \ &gt; --service-cidr=10.96.0.0/12 \ &gt; --pod-network-cidr=10.244.0.0/16 [init] Using Kubernetes version: v1.25.3 [preflight] Running pre-flight checks [WARNING FileExisting-tc]: tc not found in system path error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR CRI]: container runtime is not running: output: E1029 14:48:00.390255 29768 remote_runtime.go:948] &#34;Status from runtime service failed&#34; err=&#34;rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.RuntimeService&#34; time=&#34;2022-10-29T14:48:00+08:00&#34; level=fatal msg=&#34;getting status of runtime: rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.RuntimeService&#34; , error: exit status 1 [preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...` To see the stack trace of this error execute with --v=5 or higher 解决办法
rm -rf /etc/containerd/config.toml systemctl restart containerd # 最后使用 kubeadm reset 若出现错误
[root@k8s-master ~]# kubeadm init \ &gt; --apiserver-advertise-address=192.168.211.201 \ &gt; --image-repository registry.aliyuncs.com/google_containers \ &gt; --kubernetes-version v1.25.3 \ &gt; --service-cidr=10.96.0.0/12 \ &gt; --pod-network-cidr=10.244.0.0/16 [init] Using Kubernetes version: v1.25.3 [preflight] Running pre-flight checks [WARNING FileExisting-tc]: tc not found in system path [WARNING Hostname]: hostname &#34;k8s-master&#34; could not be reached [WARNING Hostname]: hostname &#34;k8s-master&#34;: lookup k8s-master on 223.5.5.5:53: no such host error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables does not exist [preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...` To see the stack trace of this error execute with --v=5 or higher 解决方法
modprobe br_netfilter echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables 注意： 如果要使用 kubectl get nodes 命令需要做以下配置
- master节点，root用户，执行以下命令 echo &#34;export KUBECONFIG=/etc/kubernetes/admin.conf&#34; &gt;&gt; ~/.bash_profile source ~/.bash_profile - master节点，非root用户，执行以下命令 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config - node节点需要从 master 节点拷贝 admin.con 文件到 node 节点上 scp root@master:/etc/kubernetes/admin.conf /etc/kubernetes/ - root 和 非root 用户的命令同master 7. 部署网络插件 # 以下网络插件任选一个 # CNI网络插件 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml # Flannel网络插件 kubectl apply -f https://kuboard.cn/install-script/flannel/flannel-v0.14.0.yaml # 查看 kubectl get pods -n kube-system 若发现有Pending的删除即可，会自动重新部署
[root@k8s-master ~]# kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE coredns-7f6cbbb7b8-6gxf6 0/1 Pending 0 23m coredns-7f6cbbb7b8-nnjsk 0/1 Pending 0 23m etcd-k8s-master 1/1 Running 1 23m kube-apiserver-k8s-master 1/1 Running 1 23m kube-controller-manager-k8s-master 1/1 Running 1 23m kube-proxy-6d4d6 1/1 Running 0 18m kube-proxy-m4vx9 1/1 Running 0 23m kube-scheduler-k8s-master 1/1 Running 1 23m [root@k8s-master ~]# kubectl delete pods coredns-7f6cbbb7b8-6gxf6 coredns-7f6cbbb7b8-nnjsk -n kube-system pod &#34;coredns-7f6cbbb7b8-6gxf6&#34; deleted pod &#34;coredns-7f6cbbb7b8-nnjsk&#34; deleted [root@k8s-master ~]# kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE coredns-7f6cbbb7b8-4df47 1/1 Running 0 11s coredns-7f6cbbb7b8-wxzcl 1/1 Running 0 11s etcd-k8s-master 1/1 Running 1 24m kube-apiserver-k8s-master 1/1 Running 1 24m kube-controller-manager-k8s-master 1/1 Running 1 24m kube-proxy-6d4d6 1/1 Running 0 19m kube-proxy-m4vx9 1/1 Running 0 24m kube-scheduler-k8s-master 8. 部署node节点 # 只在 master 节点执行 kubeadm token create --print-join-command # 在node节点中执行打印出的结果 kubeadm join 192.168.211.201:6443 --token hfyeoe.ie453hoen4eku70w --discovery-token-ca-cert-hash sha256:3716cd7f3c8a52b78b1ab495e7fbd3c6f7dabd899a0237c203c05bce11ac9be6 # 在 master 节点中查看 [root@k8s-master ~]# kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-master Ready control-plane,master 59m v1.22.3 k8s-node1 Ready &lt;none&gt; 54m v1.22.3 k8s-node2 Ready &lt;none&gt; 3m53s v1.22.3 注意： 若新加入的node节点出现NotReady等待一会即可
9. 添加图形化管理（选做） # 在 master 节点执行 kubectl apply -f https://addons.kuboard.cn/kuboard/kuboard-v3-swr.yaml 执行指令 watch kubectl get pods -n kuboard，等待 kuboard 名称空间中所有的 Pod 就绪
root@k8s-master ~]# kubectl get pods -n kuboard NAME READY STATUS RESTARTS AGE kuboard-agent-2-85d76b44dd-jvpm2 1/1 Running 0 9s kuboard-agent-67864c5f66-4w9z2 1/1 Running 0 9s kuboard-etcd-htppb 1/1 Running 0 36s kuboard-v3-765f7bcbfd-lpwct 0/1 Running 0 36s 访问 Kuboard 在浏览器中打开链接 http://your-node-ip-address:30080
输入初始用户名和密码，并登录
用户名： admin 密码： Kuboard123 卸载 kubectl delete -f https://addons.kuboard.cn/kuboard/kuboard-v3-swr.yaml rm -rf /usr/share/kuboard ]]></content></entry><entry><title>安装Docker</title><url>/posts/docker/%E5%AE%89%E8%A3%85docker/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html">1. 命令行安装 1.1 卸载旧版本 yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 1.2 安装 执行以下命令安装依赖包：
yum install -y yum-utils 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 执行下面的命令添加 yum 软件源：
yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 官方源 # yum-config-manager \ # --add-repo \ # https://download.docker.com/linux/centos/docker-ce.repo 更新 yum 软件源缓存，并安装 docker-ce
yum makecache yum install docker-ce docker-ce-cli containerd.io docker-scan-plugin docker-compose-plugin docker-ce-rootless-extras 1.3 防火墙额外设置 由于 CentOS8 防火墙使用了 nftables，但 Docker 尚未支持 nftables， 我们可以使用如下设置使用 iptables：
更改 vim /etc/firewalld/firewalld.conf
# FirewallBackend=nftables FirewallBackend=iptables 或者执行如下命令：
firewall-cmd --permanent --zone=trusted --add-interface=docker0 firewall-cmd --reload 2. 使用脚本自动安装 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 3. 启动Docker systemctl enable docker systemctl start docker</content></entry><entry><title>使用Docker安装常用环境</title><url>/posts/docker/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags><content type="html"><![CDATA[安装Docker $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun 卸载
dnf remove -y -q docker-ce docker-ce-cli containerd.io docker-scan-plugin docker-compose-plugin docker-ce-rootless-extras rm -rf 启动 Docker $ sudo systemctl enable docker $ sudo systemctl start docker 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。
建立 docker 组：
$ sudo groupadd docker 将当前用户加入 docker 组：
$ sudo usermod -aG docker $USER 注销用户或者重启系统 更换镜像源 vim /etc/docker/daemon.json {&#34;registry-mirrors&#34;: [&#34;http://hub-mirror.c.163.com&#34;]} systemctl restart docker 2) 腾讯云 docker hub mirror https://mirror.ccs.tencentyun.com 3) 华为云 https://05f073ad3c0010ea0f4bc00b7105ec20.mirror.swr.myhuaweicloud.com 4) docker中国 https://registry.docker-cn.com 5) 网易 http://hub-mirror.c.163.com 6) daocloud http://f1361db2.m.daocloud.io 安装Docker图形化界面 #下载 Docker 图形化界面 portainer sudo docker pull portainer/portainer #创建 portainer 容器 sudo docker volume create portainer_data #运行 portainer sudo docker run -d \ -p 9000:9000 \ --name portainer \ --restart always \ -v /var/run/docker.sock:/var/run/docker.sock \ -v portainer_data:/data \ portainer/portainer 安装MySql //拉取MySQL镜像 docker pull mysql //启动MySQL，注意更改密码，用户名为root，密码czyadmin docker run -d \ --name mysql \ --restart=always \ -p 3306:3306 \ -e MYSQL_ROOT_PASSWORD=czyadmin \ mysql 安装Redis //拉取Redis镜像 docker pull redis //启动Redis，注意更改密码，用户名为root，密码czyadmin docker run -d \ --name redis \ --restart=always \ -p 6379:6379 \ redis \ --requirepass &#34;czyadmin&#34; 安装Nginx 拉取镜像
docker pull nginx 创建本地配置文件
mkdir -p /etc/nginx/conf.d &amp;&amp; vim /etc/nginx/nginx.conf user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39; &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39; &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 启动服务
//启动nginx，映射本地配置文件 docker run -d \ --name nginx \ --restart=always \ -p 80:80 \ -v /etc/nginx/nginx.conf:/etc/nginx/nginx.conf \ -v /etc/nginx/conf.d:/etc/nginx/conf.d \ nginx vim /etc/nginx/conf.d/demo.conf server { listen 80; listen [::]:80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; } } docker exec nginx bash -c &#39;nginx -s reload&#39; 安装RabbitMQ docker pull rabbitmq:management 默认用户名和密码：guest/guest
docker run -dit \ --name rabbitmq \ --restart=always \ -p 5672:5672 \ -p 15672:15672 \ rabbitmq:management 端口 作用 15672 管理界面UI的使用端口 15671 管理监听端口 5672,5671 AMQP 0-9-1 without and with TLSclient端通信口 4369 (epmd)epmd代表Erlang端口映射守护进程，erlang发现口 25672 ( Erlang distribution) server间内部通信口 安装Postgresql docker pull postgres docker run -d \ --name postgres \ --restart=always \ -p 5432:5432 \ -e POSTGRES_PASSWORD=czyadmin \ postgres 用户名：postgres	密码：czyadmin
]]></content></entry><entry><title>树莓派使用Docker安装openwrt作为旁路由(网关服务器)</title><url>/posts/docker/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85openwrt%E4%BD%9C%E4%B8%BA%E6%97%81%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%99%A8/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag><tag>树莓派</tag></tags><content type="html"><![CDATA[
推荐使用 树莓派爱好基地的arm64无桌面增强版镜像
仓库地址： https://github.com/openfans-community-offical/Debian-Pi-Aarch64/blob/master/README_zh.md 仓库中有详细的说明文档和下载地址
开始安装openwrt容器 树莓派爱好基地的arm64无桌面增强版自带docker，可以直接使用
1. 打开网卡混杂模式 sudo ip link set eth0 promisc on 2. 创建macvlan虚拟网络，同一网段下的主机才能访问容器 下面的网段(subnet)和网关(gateway)选项请结合实际自行更改
docker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=eth0 macnet 此时，我们使用 docker network ls命令可以看到网络macnet已建立成功：
pi@raspbian:~$ docker network ls NETWORK ID NAME DRIVER SCOPE 7b8e38d3dd3c bridge bridge local f96e6360c248 host host local 7c7a5a51b268 macnet macvlan local c8c6782b8e1e none null local 3. 拉取openwrt镜像 docker pull registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi4 镜像拉取完成后，我们可以执行docker images命令查看现存镜像：
docker images REPOSITORY TAG IMAGE ID CREATED SIZE registry.cn-shanghai.aliyuncs.com/suling/openwrt rpi4 c3ba4d17a20e 32 hours ago 455MB 4. 创建并启动容器 docker run --restart always --name openwrt -d --network macnet --privileged --ip 192.168.0.200 registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi4 /sbin/init 其中：
--restart always参数表示容器退出时始终重启，使服务尽量保持始终可用；
--name openwrt参数定义了容器的名称；
-d参数定义使容器运行在 Daemon 模式(后台运行)；
--network macnet参数定义将容器加入 maxnet网络；
--privileged参数定义容器运行在特权模式下；
--ip 192.168.0.200指定容器的ip
registry.cn-shanghai.aliyuncs.com/suling/openwrt:latest为 Docker 镜像名，因容器托管在阿里云 Docker 镜像仓库内，所以在镜像名中含有阿里云仓库信息；
/sbin/init定义容器启动后执行的命令。
启动容器后，我们可以使用 docker ps -a命令查看当前运行的容器：
docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5cd19f4cd735 registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi4 &#34;/sbin/init&#34; 20 hours ago Up 7 hours openwrt 5. 进入容器修改ip,网关和dns docker exec -it openwrt ash 执行此命令后我们便进入 OpenWrt 的命令行界面，首先，我们需要编辑 OpenWrt 的网络配置文件：
vim /etc/config/network 我们需要更改 Lan 口设置：
config interface &#39;lan&#39; option ifname &#39;eth0&#39; option proto &#39;static&#39; option netmask &#39;255.255.255.0&#39; option ip6assign &#39;60&#39; option ipaddr &#39;192.168.0.200&#39; option gateway &#39;192.168.0.1&#39; option dns &#39;192.168.0.1&#39; 6. 保存后重启网络 /etc/init.d/network restart 按下Ctrl + D可以退出openwrt的终端
7. 进入luci 控制面板 在浏览器中输入第 5 步option ipaddr项目中的 IP 进入 Luci 控制面板，若option ipaddr的参数为 192.168.0.200，则可以在浏览器输入 http://192.168.0.200进入控制面板。
用户名：root
密码：password
8. 配置防火墙 在网络-防火墙-自定义规则添加以下命令后重启防火墙
iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE 9. 关闭dhcp服务 在网络-接口处删除多于的网络，只保留LAN口，点击LAN口的修改
来到最下面的基本设置，勾上忽略此接口，然后保存应用即可
10. 将网关指向openwrt 来到路由器的后台管理，将路由器的网关指向openwrt的ip地址即可
参考： https://mlapp.cn/376.html ]]></content></entry><entry><title>初次安装Git的配置</title><url>/posts/git/%E5%88%9D%E6%AC%A1%E5%AE%89%E8%A3%85git%E7%9A%84%E9%85%8D%E7%BD%AE/</url><categories><category>Git</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[初次运行 Git 前的配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：
/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。） ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 --global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。 当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。） 每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。
在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\Users\$USER ）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git 2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP 上在 C:\Documents and Settings\All Users\Application Data\Git\config ，Windows Vista 及更新的版本在 C:\ProgramData\Git\config 。此文件只能以管理员权限通过 git config -f &lt;file&gt; 来修改。
你可以通过以下命令查看所有的配置以及它们所在的文件：
$ git config --list --show-origin 用户信息 安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：
$ git config --global user.name &#34;John Doe&#34; $ git config --global user.email johndoe@example.com 再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。
检查配置信息 如果想要检查你的配置，可以使用 git config --list 命令来列出所有 Git 当时能找到的配置。
$ git config --list user.name=John Doe user.email=johndoe@example.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto ... 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。
你可以通过输入 git config &lt;key&gt;： 来检查 Git 的某一项配置
$ git config user.name John Doe 生成 SSH 公钥 许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：
$ cd ~/.ssh $ ls authorized_keys2 id_dsa known_hosts config id_dsa.pub 我们需要寻找一对以 id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件是你的公钥，另一个则是与之对应的私钥。 如果找不到这样的文件（或者根本没有 .ssh 目录），你可以通过运行 ssh-keygen 程序来创建它们。 在 Linux/macOS 系统中，ssh-keygen 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。
$ ssh-keygen -o Generating public/private rsa key pair. Enter file in which to save the key (/home/schacon/.ssh/id_rsa): Created directory &#39;/home/schacon/.ssh&#39;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/schacon/.ssh/id_rsa. Your public key has been saved in /home/schacon/.ssh/id_rsa.pub. The key fingerprint is: d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local 首先 ssh-keygen 会确认密钥的存储位置（默认是 .ssh/id_rsa），然后它会要求你输入两次密钥口令。 如果你不想在使用密钥时输入口令，将其留空即可。 然而，如果你使用了密码，那么请确保添加了 -o 选项，它会以比默认格式更能抗暴力破解的格式保存私钥。 你也可以用 ssh-agent 工具来避免每次都要输入密码。
现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员 （假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 .pub 文件内容，并将其通过邮件发送。 公钥看起来是这样的：
$ cat ~/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3 Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx NrRFi9wrf+M7Q== schacon@mylaptop.local 将公钥上传到指定服务器 # 上传公钥到服务器 $ ssh-copy-id user@host # 文件会自动上传为服务器特定文件 ～/.ssh/authorized_keys 要了解更多关于Git的知识请访问官方文档
官方文档入口 ]]></content></entry></search>